(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{473:function(t,e,r){"use strict";r.r(e);var a=r(23),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"vue-源码"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-源码"}},[t._v("#")]),t._v(" Vue 源码")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://vue-js.com/learn-vue/start/#_1-%E5%89%8D%E8%A8%80",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue"),r("OutboundLink")],1),r("br"),t._v(" "),r("a",{attrs:{href:"https://juejin.cn/post/6857669921166491662",target:"_blank",rel:"noopener noreferrer"}},[t._v("响应式原理"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"响应式原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#响应式原理"}},[t._v("#")]),t._v(" 响应式原理")]),t._v(" "),r("p",[t._v("Observer 类会通过递归的方式把一个对象的所有属性都转化成可观测对象"),r("br"),t._v("\n依赖管理器 Dep 类"),r("br"),t._v("\n数据变化时，我们不直接去通知依赖更新，而是通知依赖对应的 Watch 实例，由 Watcher 实例去通知真正的视图。\n不足:"),r("br"),t._v("\n1.虽然我们通过 Object.defineProperty 方法实现了对 object 数据的可观测，但是这个方法仅仅只能观测到 object 数据的取值及设置值，当我们向 object 数据里添加一对新的 key/value 或删除一对已有的 key/value 时，它是无法观测到的，导致当我们对 object 数据添加或删除值时，无法通知依赖，无法驱动视图进行响应式更新。"),r("br"),t._v("\n2.通过数组下标修改数组中的数据"),r("br"),t._v("\n3.通过修改数组长度清空(改变)数组\n解决:"),r("br"),t._v("\nVue 增加了两个全局 API:Vue.set 和 Vue.delete,更进一步:Proxy")]),t._v(" "),r("h2",{attrs:{id:"路由懒加载-按需加载"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#路由懒加载-按需加载"}},[t._v("#")]),t._v(" 路由懒加载(按需加载)")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.cnblogs.com/smzd/p/8665676.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("三种"),r("OutboundLink")],1),r("br"),t._v("\n非懒加载：")]),t._v(" "),r("p",[t._v("懒加载方式一：使用 import 方法，切换相应的 path 时调用组件")]),t._v(" "),r("div",{staticClass:"language-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-js"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("List")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"@/components/list.vue"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" router "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VueRouter")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  routes"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" path"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/list"')]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" component"),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" List "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),r("h2",{attrs:{id:"v-if-和-v-show"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show"}},[t._v("#")]),t._v(" v-if 和 v-show")]),t._v(" "),r("h2",{attrs:{id:"data-必须为函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#data-必须为函数"}},[t._v("#")]),t._v(" data 必须为函数")]),t._v(" "),r("p",[t._v("如果是对象，那么多个组件指向同一个对象，修改一个会导致全部都修改。\n"),r("a",{attrs:{href:"https://www.dazhuanlan.com/ren2012r4/topics/1192478",target:"_blank",rel:"noopener noreferrer"}},[t._v("例子"),r("OutboundLink")],1),t._v("\n如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响;"),r("br"),t._v("\n而 new Vue 的实例(根组件)，是不会被复用的，因此不存在引用对象的问题。"),r("a",{attrs:{href:"https://www.cnblogs.com/lovekunkun/p/12144596.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("例子"),r("OutboundLink")],1)]),t._v(" "),r("h2",{attrs:{id:"vue-生命周期"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-生命周期"}},[t._v("#")]),t._v(" Vue 生命周期")]),t._v(" "),r("p",[t._v("1、new Vue(): 执行_init 函数，初始化一些属性：如 initLifecycle、initEvents、initRender，然后执行 beforeCreate"),r("br"),t._v("\n2、调用 beforeCreate()钩子, 之后初始化 inject、state 包括 props、methods、data、computed、watch，然后执行 created"),r("br"),t._v("\n3、调用 created()钩子，所以在 created 能拿到 data 等数据，created 之后，调用 $mount() 把组件挂载到 dom 上, 然后对模板进行编译，编译过程: 生成抽象语法树 AST，优化 AST+标记静态节点(因为静态节点不更新,能够优化性能)，根据 AST 生成 render 函数, 然后执行 beforeMount"),r("br"),t._v("\n4、调用 beforeMount 钩子之后，vm._update(vm._render(), hydrating)，render 方法生成 vnode、而 update 方法会对 vnode 进行 patch，挂载到真实 dom 上，因为是首次，不需要进行新旧节点的 diff(vm._render 用来生成虚拟 dom、执行 dom-diff、更新真实 dom。)"),r("br"),t._v("\n5、调用 mounted 钩子之后，组件就已经挂载到真实 dom 上，所以可以拿到 dom"),r("br"),t._v("\n6、beforeUpdate 和 updated 的过程类似"),r("br"),t._v("\n7、beforeDestroy 和 destroyed 之间进行组件的销毁操作，比如进行清除父子关系、watcher 关闭等逻辑")]),t._v(" "),r("h2",{attrs:{id:"vue2-和-vue3-区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue2-和-vue3-区别"}},[t._v("#")]),t._v(" Vue2 和 Vue3 区别")]),t._v(" "),r("p",[t._v("1、响应式原理改为 proxy"),r("br"),t._v("\n2、diff 优化：patchFlag：给动态节点加上标记，动态节点类似于："+t._s(t.msg)+"，编译解析过程中会给动态节点添加标记。这样做有利于 diff 算法在对比 dom 树的时候，省去对比静态节点，直接对比有标记的动态节点。"),r("br"),t._v("\n3、生命周期更改：beforeCreate 和 created 被 setup 替换、beforeDestroy 替换为 beforeUnmount、destroyed 替换为 unmounted(更加语义化)"),r("br"),t._v("\n4、采用 Fragment: template 可以写多个根元素"),r("br"),t._v("\n5、更好的 Tree-Shaking"),r("br"),t._v("\nMDN：Tree shaking 是一个通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code) 行为的术语。"),r("br"),t._v("\n6、更好的支持 TS"),r("br"),t._v("\n总结：更小(tree-shaking)、更快(改用 proxy, 两个优点：性能好无需递归遍历; 不用为数组单独重写原型方法)、维护性高(monorepo 结构)、VDOM Diff 重构(标记静态节点(不需比较)、静态标记?、事件缓存?)、composition API、")]),t._v(" "),r("h2",{attrs:{id:"vue-常见问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-常见问题"}},[t._v("#")]),t._v(" Vue 常见问题")]),t._v(" "),r("p",[t._v("1、nextTick"),r("br"),t._v("\n由于 dom(数据)的更新是异步的(类比 setState)，Vue 的 this.$nextTick 方法是将执行逻辑放在 dom 更新之后执行，可以拿到最新的 dom/数据，再比如 created 钩子中 dom 还未挂载，那么也可以用这个方法来实现操作 dom。"),r("br"),t._v("\n2、"),r("a",{attrs:{href:"https://juejin.cn/post/6863241580753616903#heading-12",target:"_blank",rel:"noopener noreferrer"}},[t._v("Vue 模板编译过程"),r("OutboundLink")],1),r("br"),t._v("\n3、"),r("a",{attrs:{href:"https://segmentfault.com/a/1190000022248237",target:"_blank",rel:"noopener noreferrer"}},[t._v("keep-alive 缓存组件的原理"),r("OutboundLink")],1),r("br"),t._v("\n① 首次渲染(执行正常的生命周期钩子和 activated)的时候，除了再 "),r("keep-alive",[t._v(" 中建立缓存，设置 vnode.data.keepAlive 为 true，其他的过程和普通组件一样。"),r("br"),t._v("\n② 命中缓存进行渲染时，不执行其他钩子，只执行 activated，并且对缓存的组件进行 patch，进行更新。"),r("br"),t._v("\n4、"),r("a",{attrs:{href:"https://juejin.cn/post/6844903890278694919#heading-4",target:"_blank",rel:"noopener noreferrer"}},[t._v("前端路由"),r("OutboundLink")],1)])],1),t._v(" "),r("h2",{attrs:{id:"vue-与-react-对比"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#vue-与-react-对比"}},[t._v("#")]),t._v(" Vue 与 React 对比")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://juejin.cn/post/6844904158093377549#heading-2",target:"_blank",rel:"noopener noreferrer"}},[t._v("详细"),r("OutboundLink")],1),r("br"),t._v("\n1、响应式："),r("br"),t._v("\nVue: 2 里是 defineProperty 和发布订阅模式、3 是 proxy"),r("br"),t._v("\nReact：react 通过 setState 主动触发数据变化。\n2、diff："),r("br"),t._v("\n相同点：同层级 On、唯一 key\nVue 采用双端指针(找到同一 key 的节点，移动即可，复用)，找到新旧节点的位置，边移动指针边对比边更新"),r("br"),t._v("\nReact 是从头开始比对 node，从而去新增、删除或移动节点(没有采用双端指针)"),r("br"),t._v("\n3、事件"),r("br"),t._v("\nReact 采用合成事件，所有事件都冒泡到顶层 document 监听，然后在这里合成事件下发"),r("br"),t._v("\n4、核心思想不同"),r("br"),t._v("\nVue 推崇渐进式开发(灵活易用，只需要使用核心的响应式和 diff 即可开发)、template(静态模板)、三部分分离"),r("br"),t._v("\nReact 推崇函数式开发(hooks)、jsx(动态，更多的是写 js，复杂的 js 逻辑，更适合复杂的 js 逻辑)")]),t._v(" "),r("h2",{attrs:{id:"todo-list"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#todo-list"}},[t._v("#")]),t._v(" todo-list")])])}),[],!1,null,null,null);e.default=n.exports}}]);